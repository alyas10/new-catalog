---
order: 3
title: Задание 3. Оценка алгоритмов сортировки
---

## Варианты заданий

### **Вариант 1**

**Алгоритмы для реализации:**

1. Сортировка выбором (Selection sort) - устойчивая, O(n²)

2. Сортировка Шелла (Shell sort) - неустойчивая

### **Вариант 2**

**Алгоритмы для реализации:**

1. Сортировка перемешиванием (Cocktail sort) - устойчивая, O(n²)

2. Пирамидальная сортировка (Heapsort) - неустойчивая, O(n log n)

### **Вариант 3**

**Алгоритмы для реализации:**

1. Гномья сортировка (Gnome sort) - устойчивая, O(n²)

2. Быстрая сортировка (Quicksort) - неустойчивая, O(n log n)

### **Вариант 4**

**Алгоритмы для реализации:**

1. Сортировка вставками (Insertion sort) - устойчивая, O(n²)

2. Сортировка расчёской (Comb sort) - неустойчивая

### **Вариант 5**

**Алгоритмы для реализации:**

1. Сортировка слиянием (Merge sort) - устойчивая, O(n log n)

2. Introsort - неустойчивая, O(n log n)

### **Вариант 6**

**Алгоритмы для реализации:**

1. Сортировка с помощью двоичного дерева (Tree sort) - устойчивая, O(n log n)

2. Плавная сортировка (Smoothsort) - неустойчивая

### **Вариант 7**

**Алгоритмы для реализации:**

1. Timsort - устойчивая, O(n log n)

2. Stooge sort - неустойчивая, O(n^(log 3/log 1.5))

### **Вариант 8**

**Алгоритмы для реализации:**

1. Сортировка выбором + Сортировка вставками

2. Patience sorting - неустойчивая, O(n log n)

### **Вариант 9**

**Алгоритмы для реализации:**

1. Сортировка перемешиванием + Гномья сортировка

2. Сортировка Шелла + Быстрая сортировка

### **Вариант 10**

**Алгоритмы для реализации:**

1. Сортировка слиянием + Timsort

2. Пирамидальная сортировка + Introsort

### **Вариант 11**

**Алгоритмы для реализации:**

1. Сортировка вставками + Сортировка выбором

2. Сортировка расчёской + Плавная сортировка

### **Вариант 12**

**Алгоритмы для реализации:**

1. Деревянная сортировка + Сортировка слиянием

2. Быстрая сортировка + Stooge sort

---

## Пример оформления программы с использованием Stopwatch

```
using System;
using System.Diagnostics;
class Program
{
    static (int[], int) BubbleSort(int[] arr)
    {
        int count = 0;
        for (int i = 0; i < arr.Length; i++)
        for (int j = 0; j < arr.Length - 1; j++)
            if (arr[j] > arr[j + 1])
            {
                int t = arr[j + 1];
                arr[j + 1] = arr[j];
                arr[j] = t;
                count++;
            }
        return (arr, count);
    }
    static void UniqueTime()
    {
        Random random = new Random();
        int[] sizes = { 100, 1000, 10_000 };
        double[] times = new double[sizes.Length];
        int[] swaps = new int[sizes.Length];
        for (int i = 0; i < sizes.Length; i++)
        {
            int[] arr = new int[sizes[i]];
            for (int j = 0; j < sizes[i]; j++)
            {
                arr[j] = random.Next(-100, 101);
            }
            Stopwatch stopwatch = Stopwatch.StartNew();
            var result = BubbleSort(arr);
            stopwatch.Stop();
            times[i] = stopwatch.Elapsed.TotalSeconds;
            swaps[i] = result.Item2;
        }
        Console.WriteLine("Вид сортировки: Bubble Sort");
        Console.WriteLine();
        Console.WriteLine($"{"Параметр",-15} {"(n=100)",-15} {"(n=1000)",-15} {"(n=10000)",-15}");
        Console.WriteLine($"{"Время (с)",-15} {times[0],-15:F6} {times[1],-15:F6} {times[2],-15:F6}");
        Console.WriteLine($"{"Перестановки",-15} {swaps[0],-15} {swaps[1],-15} {swaps[2],-15}");
    }
    static void Main()
    {
        UniqueTime();
    }
}
```

## Тестирование программы

![](./zadanie-3-ocenka-algoritmov-sortirovki.png){width=827px height=181px}

Данный алгоритм имеет сложность **O(n²)**, т.к. первый цикл имеет сложность **O(n)**, второй цикл -- **O(n/2)**. По правилу умножения: **O(n) × O(n/2) = O(n²/2)**, но так как константы в общей сложности не учитываются, то итоговая сложность -- **O(n²)**.

**Таблица результатов (пример для двух алгоритмов):**

| Параметр     | Алгоритм 1 (n=100) | Алгоритм 1 (n=1000) | Алгоритм 1 (n=10000) | Алгоритм 2 (n=100) | Алгоритм 2 (n=1000) | Алгоритм 2 (n=10000) |
|--------------|--------------------|---------------------|----------------------|--------------------|---------------------|----------------------|
| Время (с)    | 0\.003524          | 0\.198670           | 11\.685689           | 0\.001234          | 0\.045678           | 0\.987654            |
| Перестановки | 2302               | 249192              | 24720985             | 1500               | 150000              | 15000000             |

## Пример вывода для сравнения сортировок

**Выводы**: В результате проведённого эксперимента эффективным из представленных алгоритмов является быстрая сортировка, которая полностью оправдывает своё название. Имея незначительную разницу во времени при упорядочивании небольших массивов (до 1'000 элементов), она проявляет весь свой потенциал при работе с большими массивами данных (свыше 10'000 элементов), что является ключевым преимуществом при работе в крупных проектах. 

Сортировка слиянием при упорядочивании небольших массивов (до 1'000 элементов) демонстрирует хорошие показатели, однако при сортировке массивов среднего и большого объёма (свыше 10'000 элементов) она показывает неудовлетворительные результаты. Сортировки пузырьком, выбором и вставками имеют схожие алгоритмы работы и показывают неудовлетворительные результаты с массивами любой разрядности. Самым медленным способом сортировки является шейкерная. Она показывает худшие результаты в массивах любой размерности и к работе с коммерческими проектами категорически не допускается.


